<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<style type="text/css">
  #test {
    width: 60%;
    height: 500px;
    border: 1px solid grey;
  }
  #test svg {
    width: 100%;
    height: 100%;
  }

  #line{
    width: 700px;
    margin: 20px 0;
    height: 300px;
    background: #eee;
  }

  .role {
    rx: 20px;
    ry: 20px;
  }

  div.buttons-div {
    width: 60%;
  }

  ul.buttons-ul {
    width: 100%;
    height: 100px;
    text-align: center;
    margin-top: 20px;
    list-style-type: none;
  }

  li.button {
    
    text-decoration: none;
    width: 50px;
    height: 50px;
    background-color: #655ad9;
    border-radius: 50%;
    display: inline-block;
    cursor: pointer;
  }

  li.button.active {
    background-color: #9DB828;
  }

  span.button-text {
    line-height: 48px;
    font-size: 22px;
    color: white;
    font-family: "Arial"
  }
â€‹</style>
</head>
<body>
  <div id="test">
  </div>

  <div class="buttons-div">
    <ul class="buttons-ul">
      <li class="button" step="1"><span class="button-text" >1</span></li>
      <li class="button" step="2"><span class="button-text" >2</span></li>
      <li class="button" step="3"><span class="button-text" >3</span></li>
   </ul>
   </div>

  <script type="text/javascript" src="js/jquery-2.1.1.min.js"></script>
  <script type="text/javascript" src="js/d3.v3.min.js"></script>
  <script type="text/javascript">

$( document ).ready(function() {
  var CURVED_LINES = false;

  var   w = $('#test').width(),
          h = $('#test').height();

    // var w = 700;
    // var h = 300;
  var  x = function(d) {return d.x},
        y = function(d) {return d.y};

  var textCircleRadius = 15;

  var lineFunction = d3.svg.line()
                              .x(x)
                              .y(y)
                              .interpolate("cardinal");

  var pubWidth = 100,
        pubHeight = 80,
        pubXOffsetFactor = 0.05,
        pubYOffsetFactor = 0.7;

  var bcRadius = 30,
        bcXOffsetFactor = 0.5,
        bcYOffsetFactor = 0.2;

  var defs = 
        { 
            pub: {
                w: pubWidth, 
                h: pubHeight,
                x: w * pubXOffsetFactor, 
                y: h * 0.7
            },
            prov: {
               w: pubWidth, 
               h: pubHeight,
                x: w * (1 - pubXOffsetFactor) - pubWidth, 
                y: h* pubYOffsetFactor
            },
            bc: {
              radius: bcRadius,
              cx: w* bcXOffsetFactor,
              cy: h* bcYOffsetFactor
            }
        };

  var markerParams;
  var anchorOffset = 15;

   var getAngle = function(center, point) {
        var dx = point.x - center.x,
              dy = (point.y - center.y);

        var angleRad = Math.atan2(dy , dx) + (Math.PI / 2),
              angleDeg = (angleRad * 180 / Math.PI);

        console.log('angleRad', angleRad);
        console.log('angleDeg', angleDeg);
   }

    var linePoints = function(p1, p2) {
        var  isBezier = CURVED_LINES || false,
              offset = isBezier ? 100 : 0,
              center = {
                  x: p1.x + (p2.x - p1.x) / 2,
                  y: p1.y + (p2.y - p1.y) / 2 + offset
              } 

        return [p1, center, p2];
    }

    var getPath = function(points, isClosedShape) {
        var isClosedShape = isClosedShape || false;
        var d;

        // use Bezier curves
        if (CURVED_LINES) {

        }

        else {
            var lineGenerator = d3.svg.line()
            .x(function(d) { return d.x; })
            .y(function(d) { return d.y; })
            .interpolate("linear");

            d = lineGenerator(points);
        }

       
        return d;
    }

    var getMarkerParams = function(id, width, height, stroke_width, stroke_color, fill) {
          var indent = Math.ceil(width / 10);

          var markerParams = {
              id: id,
              viewBox: "0 0 " + width + " " + height,
              orient: "auto",
              refX: 10,//width  / 2,
              refY: height / 2,
              markerUnits: 'userSpaceOnUse', //stroke_width,
              markerWidth: width,
              markerHeight: height,
              d: "M0,0 L" + (width - 10) + "," + (height / 2) + " 0," + height + " " + indent + "," + (height / 2) + " Z",
              strokeWidth: stroke_width,
              strokeColor: stroke_color,
              fill: fill 
          }

        return markerParams;
    }

    var getAnchorPoint = function(role, side, type, offset) {
        var offset = offset || {x:0, y:0};

        if (defs[role]) {
            if (defs[role].anchor && defs[role].anchor[side]) {
            
                if (type === 'origin') {
                    return {
                      x: defs[role].anchor[side].x + offset.x,
                      y: defs[role].anchor[side].y + offset.y
                    }
                }
                else { // TERMINUS e.g. the arrow tip
                    // offset the anchor point
                    switch(side) {
                        case 'left': 
                            return {
                                  x: defs[role].anchor[side].x - anchorOffset + offset.x,
                                  y: defs[role].anchor[side].y + offset.y
                            }
                        
                         case 'right': 
                              return {
                                    x: defs[role].anchor[side].x + anchorOffset + offset.x,
                                    y: defs[role].anchor[side].y + offset.y
                              }

                        case 'bottomLeft':
                            if (role === 'bc') {
                                return {
                                      x: defs.bc.cx - (defs.bc.radius ) + offset.x, 
                                      y: defs.bc.cy + (defs.bc.radius) + offset.y
                                }
                            }
                            break;

                         case 'bottomRight':
                            if (role === 'bc') {
                                return {
                                      x: defs.bc.cx + defs.bc.radius + offset.x,
                                      y: defs.bc.cy + defs.bc.radius + offset.y
                                }
                            }
                            break; 
                    }
                }
            }
        }

        return {x: 0, y: 0};
    }

    var textOffset = function(points) {
      
       var d = 30;
       var start = points[0],
            end = points[2];

       var a,
            angle;

       var offset = {x:0, y:0};

       if  (end.x === start.x) { // vertical line
            return {x:d, y:0};
       }

       a = (end.y - start.y) / (end.x - start.x);

       angle = Math.atan(a);

       offset= {
          x: -1 * d * Math.sin(angle),
          y: d * Math.cos(angle)
       }

       return offset;
    }

    markerParams = getMarkerParams("arrow-head", 30, 30, 0.5, "black", "steelblue");

    defs.pub.center = {x: defs.pub.x + defs.pub.w / 2, y: defs.pub.y + defs.pub.h / 2};
    defs.pub.anchor = {
          left: {x: defs.pub.x, y: defs.pub.center.y }, 
          right: {x: defs.pub.x + defs.pub.w, y: defs.pub.center.y}
    };
    defs.prov.center = {x: defs.prov.x + defs.prov.w / 2, y: defs.prov.y + defs.prov.h / 2};
    defs.prov.anchor = {
          left: {x: defs.prov.x, y: defs.prov.center.y }, 
          right: {x: defs.prov.x + defs.prov.w, y: defs.prov.center.y}
    };

    defs.bc.center = {x: defs.bc.cx, y: defs.bc.cy};
    defs.bc.anchor = {
      bottomLeft: {x: defs.bc.cx - (defs.bc.radius * Math.cos(Math.PI / 4)), y: defs.bc.cy + (defs.bc.radius * Math.cos(Math.PI / 4))},
      bottomRight: {x: defs.bc.cx + (defs.bc.radius * Math.cos(Math.PI / 4)), y: defs.bc.cy + (defs.bc.radius * Math.sin(Math.PI / 4))}
    };

    var lineData = [
      [], // 0
      [   // 1
          {
            id: 1,
            type: 'direct',
            start: linePoints(getAnchorPoint('pub' ,'right', 'origin'), getAnchorPoint('pub' ,'right', 'origin')), 
            end: linePoints(getAnchorPoint('pub' ,'right', 'origin'), getAnchorPoint('prov' ,'left', 'terminus'))
          },
          {
            id: 2,
            type: 'blockchain',
            start: linePoints(getAnchorPoint('pub' ,'right', 'origin'), getAnchorPoint('pub' ,'right', 'origin')), 
            end: linePoints(getAnchorPoint('pub' ,'right', 'origin'), getAnchorPoint('bc' ,'bottomLeft', 'terminus'))
          }
      ],
      [
          {
            id: 3,
            type: 'direct',
            start: linePoints(getAnchorPoint('prov' ,'left', 'origin'), getAnchorPoint('prov' ,'left', 'origin')), 
            end: linePoints(getAnchorPoint('prov' ,'left', 'origin'), getAnchorPoint('pub' ,'right', 'terminus'))
          },
          {
            id: 4,
            type: 'blockchain',
            start: linePoints(defs.bc.center, defs.bc.center), 
            end: linePoints(defs.bc.center, getAnchorPoint('prov' ,'left', 'terminus', {x:0, y: -15}))
          }
      ]
    ]

    
    console.log(defs.pub.center);

    

    var svg = d3.select("#test")
          .append("svg")
          // .attr("width", w)
          // .attr("height", h)
          .attr("id", "vis")
          .attr("xmlns", "http://www.w3.org/2000/svg");

    var svgdefs =  svg.append("defs");

    var marker = svgdefs.append("marker")
              .attr("id", markerParams.id)
              .attr("viewBox", markerParams.viewBox)
              .attr("orient", markerParams.orient)
              .attr('markerUnits', markerParams.markerUnits)
              .attr("refX", markerParams.refX)
              .attr("refY", markerParams.refY)
              .attr("markerWidth", markerParams.markerWidth)
              .attr("markerHeight", markerParams.markerHeight);
              
      var markerPath = marker.append("path")
              .attr("d", markerParams.d)
              .attr("stroke-width", markerParams.strokeWidth)
              .attr("stroke-color", markerParams.strokeColor)
              .attr("fill", markerParams.fill);

  
    var lg1 = svg.append("g")
            .attr("class", "line-group")
            .attr("id", "lg1");
    
    var lg2 = svg.append("g")
            .attr("class", "line-group")
            .attr("id", "lg2");
                    
    var publisher = svg.append('rect')
            .attr('id', 'publisher')
            .attr('class', 'role')
            .attr('width', defs.pub.w)
            .attr('height', defs.pub.h)
            .attr('rx', 10)
            .attr('ry', 10)
            .attr('transform', 'translate(' + defs.pub.x + ', ' + defs.pub.y + ')')
            .attr('fill', 'none')
            .attr('stroke-width', 10)
            .attr('stroke', 'purple');

    var provider = svg.append('rect')
            .attr('id', 'provider')
            .attr('class', 'role')
            .attr('width', defs.prov.w)
            .attr('height', defs.prov.h)
            .attr('rx', 10)
            .attr('ry', 10)
            .attr('transform', 'translate(' + defs.prov.x + ', ' + defs.prov.y + ')')
            .attr('fill', 'none')
            .attr('stroke-width', 10)
            .attr('stroke', 'orange');
          
    var blockchain = svg.append("circle")
            .attr('id', "blockchain")
            .attr('r', defs.bc.radius)
            // .attr('cx', defs.bc.cx)
            // .attr('cy', defs.bc.cy)
            .attr('transform', 'translate(' + defs.bc.cx + ', ' + defs.bc.cy + ')')
            .attr('fill', 'green');
          
   
   // update(1);

   // setTimeout(function() {update(2)}, 2000);

function update(step) {
    var durationArrow = 500,
          durationLabel = 500,
          durationRemove = 500;

    var arrows = lg1.selectAll("path.arrow")
          .data(lineData[step], function(d) {return d.id});

      arrows.enter()
          .append("path")
          .attr('class', 'arrow')
          .attr("marker-end", "url(#arrow-head)")
          .attr("d", function (d) { return getPath(d.start) })
          .attr("stroke", "steelblue")
          .attr("stroke-width", 12)
          .attr("fill", "none")
          .attr('opacity', 1)
        .transition()
              .duration(durationArrow)
              .attr("d", function (d) { return getPath(d.end) });
    
      arrows.exit()
            .transition()
              .duration(durationRemove)
              .attr('opacity', 0)
            .transition()
              .delay(durationRemove)
              .remove();

      var arrowCircles = lg1.selectAll("circle")
          .data(lineData[step], function(d) {return d.id});

       arrowCircles.enter()
            .append("circle")
            .attr("cx", function(d) {return d.end[1].x  + textOffset(d.end).x})
            .attr("cy", function(d) {return d.end[1].y  + textOffset(d.end).y})
            .attr("r", 0)
            .attr("fill", "none")
            .attr("stroke", "steelblue")
            .attr("stroke-width", 2)
            .attr('opacity', 1)
        .transition()
            .delay(durationArrow)
            .duration(durationLabel)
            .ease('elastic')
            .attr("r", textCircleRadius);

      arrowCircles.exit()
            .transition()
              .duration(durationRemove)
              .attr('opacity', 0)
            .transition()
              .delay(durationRemove)
              .remove();

      var arrowText = lg1.selectAll("text")
          .data(lineData[step], function(d) {return d.id});

      arrowText.enter()
            .append("text")
            .attr("x", function(d) {return d.end[1].x  + textOffset(d.end).x})
            .attr("y", function(d) {return d.end[1].y  +textOffset(d.end).y + 6})
            .attr("text-anchor", "middle")
            .attr("font-family", "sans-serif")
            .attr("font-size", "18px")
            .attr("fill", "red")
            .attr('opacity', 0)
            .text(function(d) {return d.id})
        .transition()
            .delay(durationArrow)
            .duration(durationLabel)
            .attr('opacity', 1);

      arrowText.exit()
            .transition()
              .duration(durationRemove)
              .attr('opacity', 0)
            .transition()
              .delay(durationRemove)
              .remove();
      } //update
   
      /*******************     EVENT HANDLERS   *****************/
      $('li.button').click(function() {
          var step = parseInt($(this).attr('step'));

          console.log('STEP', $(this).attr('step'))
          $('li.button.active').removeClass('active');
          $(this).addClass('active');

          update(step);
      })
    });
  </script>
</body>
</html>