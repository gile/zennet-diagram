<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<style type="text/css">
  #test {
    width: 60%;
    height: 500px;
    border: 1px solid grey;
  }
  #test svg {
    width: 100%;
    height: 100%;
  }

  #line{
    width: 700px;
    margin: 20px 0;
    height: 300px;
    background: #eee;
  }

  .role {
    rx: 20px;
    ry: 20px;
  }

  button {
    margin: 20px 0 0 20px;
  }
​</style>
</head>
<body>
  <div id="test">
  </div>

  <div id="line"></div>​
  <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
  <script type="text/javascript" src="http://mbostock.github.com/d3/d3.js?2.5.0"></script>
  <script type="text/javascript">

$( document ).ready(function() {
  var CURVED_LINES = false;

  var   w = $('#test').width(),
          h = $('#test').height();

    // var w = 700;
    // var h = 300;
  var  x = function(d) {return d.x},
          y = function(d) {return d.y};

  var textCircleRadius = 15;

  var lineFunction = d3.svg.line()
                              .x(x)
                              .y(y)
                              .interpolate("cardinal");

  var pubWidth = 100,
        pubHeight = 80,
        pubXOffsetFactor = 0.05,
        pubYOffsetFactor = 0.7;

  var bcRadius = 30,
        bcXOffsetFactor = 0.5,
        bcYOffsetFactor = 0.2;

  var defs = 
        { 
            pub: {
                w: pubWidth, 
                h: pubHeight,
                x: w * pubXOffsetFactor, 
                y: h * 0.7
            },
            prov: {
               w: pubWidth, 
               h: pubHeight,
                x: w * (1 - pubXOffsetFactor) - pubWidth, 
                y: h* pubYOffsetFactor
            },
            bc: {
              radius: bcRadius,
              cx: w* bcXOffsetFactor,
              cy: h* bcYOffsetFactor
            }
        };

   var getAngle = function(center, point) {
        var dx = point.x - center.x,
              dy = (point.y - center.y);

        var angleRad = Math.atan2(dy , dx) + (Math.PI / 2),
              angleDeg = (angleRad * 180 / Math.PI);

        console.log('angleRad', angleRad);
        console.log('angleDeg', angleDeg);
   }

    var linePoints = function(p1, p2) {
        var  isBezier = CURVED_LINES || false,
              offset = isBezier ? 100 : 0,
              center = {
                  x: p1.x + (p2.x - p1.x) / 2,
                  y: p1.y + (p2.y - p1.y) / 2 + offset
              } 

        return [p1, center, p2];
    }

    var getPath = function(points, isClosedShape) {
        var isClosedShape = isClosedShape || false;
        var d;

        // use Bezier curves
        if (CURVED_LINES) {

        }

        else {
            var lineGenerator = d3.svg.line()
            .x(function(d) { return d.x; })
            .y(function(d) { return d.y; })
            .interpolate("linear");

            d = lineGenerator(points);
        }

       
        return d;
    }

    var getMarkerParams = function(id, width, height, stroke_width, stroke_color, fill) {
          var indent = Math.ceil(width / 10);

          var markerParams = {
              id: id,
              viewBox: "0 0 " + width + " " + height,
              orient: "auto",
              refX: 10,//width  / 2,
              refY: height / 2,
              markerUnits: 'userSpaceOnUse', //stroke_width,
              markerWidth: width,
              markerHeight: height,
              d: "M0,0 L" + (width - 10) + "," + (height / 2) + " 0," + height + " " + indent + "," + (height / 2) + " Z",
              strokeWidth: stroke_width,
              strokeColor: stroke_color,
              fill: fill 
          }

        return markerParams;
    }

    var getAnchorPoint = function(role, side, type) {
        if (defs[role]) {
            if (defs[role].anchor && defs[role].anchor[side]) {
                if (type === 'origin') {
                    return defs[role].anchor[side];
                }
                else { // TERMINUS e.g. the arrow tip
                    // offset the anchor point
                    switch(side) {
                        case 'left': 
                            return {
                                  x: defs[role].anchor[side].x - anchorOffset,
                                  y: defs[role].anchor[side].y
                            }
                        
                         case 'right': 
                              return {
                                    x: defs[role].anchor[side].x + defs[role].w + anchorOffset,
                                    y: defs[role].anchor[side].y
                              }

                        case 'bottomLeft':
                            if (role === 'bc') {
                                return {
                                      x: defs.bc.cx - (defs.bc.radius ), 
                                      y: defs.bc.cy + (defs.bc.radius)
                                }
                            }
                            break;

                         case 'bottomRight':
                            if (role === 'bc') {
                                return {
                                      x: defs.bc.cx + defs.bc.radius, 
                                      y: defs.bc.cy + defs.bc.radius
                                }
                            }
                            break; 
                    }
                }
            }
        }

        return {x: 0, y: 0};
    }

    var markerParams = getMarkerParams("arrow-head", 30, 30, 0.5, "black", "steelblue");
    var anchorOffset = 15;

    defs.pub.center = {x: defs.pub.x + defs.pub.w / 2, y: defs.pub.y + defs.pub.h / 2};
    defs.pub.anchor = {
          left: {x: defs.pub.x, y: defs.pub.center.y }, 
          right: {x: defs.pub.x + defs.pub.w, y: defs.pub.center.y}
    };
    defs.prov.center = {x: defs.prov.x + defs.prov.w / 2, y: defs.prov.y + defs.prov.h / 2};
    defs.prov.anchor = {
          left: {x: defs.prov.x, y: defs.prov.center.y }, 
          right: {x: defs.prov.x + defs.prov.w, y: defs.prov.center.y}
    };

    defs.bc.anchor = {
      bottomLeft: {x: defs.bc.cx - (defs.bc.radius * Math.cos(Math.PI / 4)), y: defs.bc.cy + (defs.bc.radius * Math.cos(Math.PI / 4))},
      bottomRight: {x: defs.bc.cx + (defs.bc.radius * Math.cos(Math.PI / 4)), y: defs.bc.cy + (defs.bc.radius * Math.sin(Math.PI / 4))}
    };

    var lineData = [
      {
        type: 'direct',
        start: linePoints(getAnchorPoint('pub' ,'right', 'origin'), getAnchorPoint('pub' ,'right', 'origin')), 
        end: linePoints(getAnchorPoint('pub' ,'right', 'origin'), getAnchorPoint('prov' ,'left', 'terminus'))
      },
      {
        type: 'blockchain',
        start: linePoints(getAnchorPoint('pub' ,'right', 'origin'), getAnchorPoint('pub' ,'right', 'origin')), 
        end: linePoints(getAnchorPoint('pub' ,'right', 'origin'), getAnchorPoint('bc' ,'bottomLeft', 'terminus'))
      }
    ]

    
    console.log(defs.pub.center);

    

    var svg = d3.select("#test")
          .append("svg")
          // .attr("width", w)
          // .attr("height", h)
          .attr("id", "vis")
          .attr("xmlns", "http://www.w3.org/2000/svg");

    var svgdefs =  svg.append("defs");

    var marker = svgdefs.append("marker")
              .attr("id", markerParams.id)
              .attr("viewBox", markerParams.viewBox)
              .attr("orient", markerParams.orient)
              .attr('markerUnits', markerParams.markerUnits)
              .attr("refX", markerParams.refX)
              .attr("refY", markerParams.refY)
              .attr("markerWidth", markerParams.markerWidth)
              .attr("markerHeight", markerParams.markerHeight);
              
      var markerPath = marker.append("path")
              .attr("d", markerParams.d)
              .attr("stroke-width", markerParams.strokeWidth)
              .attr("stroke-color", markerParams.strokeColor)
              .attr("fill", markerParams.fill);

  
    var lg1 = svg.append("g")
            .attr("class", "line-group")
            .attr("id", "lg1");
    
    var lg2 = svg.append("g")
            .attr("class", "line-group")
            .attr("id", "lg2");
                    
    var publisher = svg.append('rect')
            .attr('id', 'publisher')
            .attr('class', 'role')
            .attr('width', defs.pub.w)
            .attr('height', defs.pub.h)
            .attr('rx', 10)
            .attr('ry', 10)
            .attr('transform', 'translate(' + defs.pub.x + ', ' + defs.pub.y + ')')
            .attr('fill', 'none')
            .attr('stroke-width', 10)
            .attr('stroke', 'purple');

    var provider = svg.append('rect')
            .attr('id', 'provider')
            .attr('class', 'role')
            .attr('width', defs.prov.w)
            .attr('height', defs.prov.h)
            .attr('rx', 10)
            .attr('ry', 10)
            .attr('transform', 'translate(' + defs.prov.x + ', ' + defs.prov.y + ')')
            .attr('fill', 'none')
            .attr('stroke-width', 10)
            .attr('stroke', 'orange');
          
    var blockchain = svg.append("circle")
            .attr('id', "blockchain")
            .attr('r', defs.bc.radius)
            // .attr('cx', defs.bc.cx)
            // .attr('cy', defs.bc.cy)
            .attr('transform', 'translate(' + defs.bc.cx + ', ' + defs.bc.cy + ')')
            .attr('fill', 'green');
          
   
   update();
   
function update() {
    lg1.selectAll("path.arrow")
          .data(lineData)
        .enter()
          .append("path")
          .attr("marker-end", "url(#arrow-head)")
          .attr("d", function (d) { return getPath(d.start) })
          .attr("stroke", "steelblue")
          .attr("stroke-width", 12)
          .attr("fill", "none")
        .transition()
              .duration(1000)
              .attr("d", function (d) { return getPath(d.end) });
    
      var textOffset = {
            direct: 30,
            blockchain: 20
        }

      lg1.selectAll("circle")
          .data(lineData)
        .enter()
            .append("circle")
            .attr("cx", function(d) {return d.end[1].x  + textOffset[d.type]})
            .attr("cy", function(d) {return d.end[1].y  + textOffset[d.type]})
            .attr("r", 0)
            .attr("fill", "none")
            .attr("stroke", "steelblue")
            .attr("stroke-width", 2)
        .transition()
            .duration(1200)
            .ease('elastic')
            .attr("r", textCircleRadius);

      lg1.selectAll("text")
          .data(lineData)
        .enter()
            .append("text")
            .attr("x", function(d) {return d.end[1].x  + textOffset[d.type]})
            .attr("y", function(d) {return d.end[1].y  + textOffset[d.type] + 5})
            .attr("text-anchor", "middle")
            .attr("font-family", "sans-serif")
            .attr("font-size", "18px")
            .attr("fill", "red")
            .text(function(d, i) {return i});
}
      // var c1 = lg1.append("circle")
      //       .attr("cx", lineData[0].end[1].x  + textOffset)
      //       .attr("cy", lineData[0].end[1].y + textOffset)
      //       .attr("r", 0)
      //       .attr("fill", "none")
      //       .attr("stroke", "steelblue")
      //       .attr("stroke-width", 2);

      // c1.transition()
      //       .duration(1200)
      //       .ease('elastic')
      //       .attr("r", radius);

      // var text1 = lg1.append("text")
      //       .attr("x", lineData[0].end[1].x + textOffset)
      //       .attr("y", lineData[0].end[1].y + textOffset + 5)
      //       .attr("text-anchor", "middle")
      //       .attr("font-family", "sans-serif")
      //       .attr("font-size", "18px")
      //       .attr("fill", "red")
      //       .text("1");
       

//  var cloudPoints = [{x:10, y:120}, {x:30, y:90}, {x:80, y:80}, {x:100, y:125}, {x:70, y:220}, {x:10, y:120}],
//         cloud = function(points) {
//               var d = "M" + points[0].x + "," + points[0].y;
//               for (var i=1; i<points.length; ++i) {
//                      d += " A30,30 0 0,1 " + points[i].x+ "," + points[i].y
//               }
//               d += "Z";
//               return d;
//           }(cloudPoints);
    
// svg.append("path")
//     .attr('d', cloud)
//     .attr("stroke", "red")
//     .attr("stroke-width", 2)
//     .attr("fill", "none");

    // var data = d3.range(11).map(function(){return Math.random()*10})
    // var x = d3.scale.linear().domain([0, 10]).range([0, 700]);
    // var y = d3.scale.linear().domain([0, 10]).range([10, 290]);
    // var line = d3.svg.line()
    //   .interpolate("cardinal")
    //   .x(function(d,i) {return x(i);})
    //   .y(function(d) {return y(d);})

    // var path = svg.append("path")
    //   .attr("d", line(data))
    //   .attr("stroke", "steelblue")
    //   .attr("stroke-width", "2")
    //   .attr("fill", "none");

    // var totalLength = path.node().getTotalLength();

    // path
    //   .attr("stroke-dasharray", totalLength + " " + totalLength)
    //   .attr("stroke-dashoffset", totalLength)
    //   .transition()
    //     .duration(2000)
    //     .ease("linear")
    //     .attr("stroke-dashoffset", 0);

    // svg.on("click", function(){
    //   path      
    //     .transition()
    //     .duration(2000)
    //     .ease("linear")
    //     .attr("stroke-dashoffset", totalLength);
    // })
    

    });
  </script>
</body>
</html>