<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<style type="text/css">
  #stage {
    width: 650px;
    height: 450px;
    border: 1px solid grey;
  }
  #stage svg {
    width: 100%;
    height: 100%;
  }

  #line{
    width: 700px;
    margin: 20px 0;
    height: 300px;
    background: #eee;
  }

  #publisher {
      transform-origin: 130px, 325px;
  }

  #provider {
      transform-origin: 315px, 325px;
  }
  
  #vm {
      transform-origin: 473px, 337px;
  }
  
  #blockchain {
     transform-origin: 320px, 90px;
  }

  .role {
    rx: 20px;
    ry: 20px;
  }

  div.buttons-div {
    width: 650px;
  }

  ul.buttons-ul {
    width: 100%;
    height: 100px;
    text-align: center;
    margin-top: 20px;
    padding: 0;
    list-style-type: none;
  }

  li.button {
    
    text-decoration: none;
    width: 50px;
    height: 50px;
    background-color: #655ad9;
    border-radius: 50%;
    display: inline-block;
    cursor: pointer;
  }

  li.button.active {
    background-color: #9DB828;
  }

  span.button-text {
    line-height: 48px;
    font-size: 22px;
    color: white;
    font-family: "Arial"
  }
â€‹</style>
</head>
<body>
  <div id="stage"> <!-- Fallback Text Content can go here --> </div>
 
<!-- <object type="image/svg+xml" data="publisher.svg" class="logo">
</object> -->

  <div class="buttons-div">
    <ul class="buttons-ul">
      <li class="button" step="1"><span class="button-text" >1</span></li>
      <li class="button" step="2"><span class="button-text" >2</span></li>
      <li class="button" step="3"><span class="button-text" >3</span></li>
   </ul>
   </div>

  <script type="text/javascript" src="js/jquery-2.1.1.min.js"></script>
  <script type="text/javascript" src="js/d3.v3.min.js"></script>
  <script type="text/javascript">

$( document ).ready(function() {
  var CURVED_LINES = false;

  var   w = $('#stage').width(),
          h = $('#stage').height();

    // var w = 700;
    // var h = 300;
  var  x = function(d) {return d.x},
        y = function(d) {return d.y};

  var textCircleRadius = 15;

  var markerParams;
  var anchorOffset = {x:12, y: 8};
  var defs;
  var lineData;
  var lg1, lg2;
  var publisher, provider, vm, blockchain;
  var vmTranslate = {x: -50, y: 50};

  var lineFunction = d3.svg.line()
                              .x(x)
                              .y(y)
                              .interpolate("cardinal");

   var getAngle = function(center, point) {
        var dx = point.x - center.x,
              dy = (point.y - center.y);

        var angleRad = Math.atan2(dy , dx) + (Math.PI / 2),
              angleDeg = (angleRad * 180 / Math.PI);  
   }

    var linePoints = function(p1, p2) {
        if (!p1) { return [ {x:0, y:0}, {x:0, y:0}, {x:0, y:0}]; }

        var p2 = p2 || p1;
        var  isBezier = CURVED_LINES || false,
              offset = isBezier ? 100 : 0,
              center = {
                  x: p1.x + (p2.x - p1.x) / 2,
                  y: p1.y + (p2.y - p1.y) / 2 + offset
              } 

        return [p1, center, p2];
    }

    var getPath = function(points, isClosedShape) {
        var isClosedShape = isClosedShape || false;
        var d;

        // use Bezier curves
        if (CURVED_LINES) {

        }

        else {
            var lineGenerator = d3.svg.line()
            .x(function(d) { return d.x; })
            .y(function(d) { return d.y; })
            .interpolate("linear");

            d = lineGenerator(points);
        }

       
        return d;
    }

    var getMarkerParams = function(id, width, height, stroke_width, stroke_color, fill) {
          var indent = Math.ceil(width / 10);

          var markerParams = {
              id: id,
              viewBox: "0 0 " + width + " " + height,
              orient: "auto",
              refX: 10,//width  / 2,
              refY: height / 2,
              markerUnits: 'userSpaceOnUse', //stroke_width,
              markerWidth: width,
              markerHeight: height,
              d: "M0,0 L" + (width - 10) + "," + (height / 2) + " 0," + height + " " + indent + "," + (height / 2) + " Z",
              strokeWidth: stroke_width,
              strokeColor: stroke_color,
              fill: fill 
          }

        return markerParams;
    }

    var getAnchorPoint = function(role, side, type, offset) {
        var offset = offset || {x:0, y:0};


        if (defs[role]) {
            if (defs[role].anchor && defs[role].anchor[side]) {
            
                if (type === 'origin') {
                    return {
                      x: defs[role].anchor[side].x + offset.x,
                      y: defs[role].anchor[side].y + offset.y
                    }
                }
                else { // TERMINUS e.g. the arrow tip
                    // offset the anchor point
                    switch(side) {
                        case 'left': 

                            return {
                                  x: defs[role].anchor[side].x - anchorOffset.x + offset.x,
                                  y: defs[role].anchor[side].y + offset.y
                            }
                        
                         case 'right': 
                              return {
                                    x: defs[role].anchor[side].x + anchorOffset.x + offset.x,
                                    y: defs[role].anchor[side].y + offset.y
                              }

                        case 'top': 
                              return {
                                    x: defs[role].anchor[side].x  + offset.x,
                                    y: defs[role].anchor[side].y - anchorOffset.y + offset.y
                              }

                        case 'bottomLeft':
                            if (role === 'bc') {
                                return {
                                      x: defs.bc.cx - (defs.bc.radius ) + offset.x, 
                                      y: defs.bc.cy + (defs.bc.radius) + offset.y
                                }
                            }
                            break;

                         case 'bottomRight':
                            if (role === 'bc') {
                                return {
                                      x: defs.bc.cx + defs.bc.radius + offset.x,
                                      y: defs.bc.cy + defs.bc.radius + offset.y
                                }
                            }
                            break; 
                    }
                }
            }
        }

        return {x: 0, y: 0};
    }

    var textOffset = function(points) {
      
       var d = 30;
       var start = points[0],
            end = points[2];

       var a,
            angle;

       var offset = {x:0, y:0};

       if  (end.x === start.x) { // vertical line
            return {x:d, y:0};
       }

       a = (end.y - start.y) / (end.x - start.x);

       angle = Math.atan(a);

       offset= {
          x: -1 * d * Math.sin(angle),
          y: d * Math.cos(angle)
       }

       return offset;
    }

    function showAnchorPoints() {

        var centerPoints = [
            defs.pub.center,
            defs.prov.center,
            defs.vm.center,
            defs.bc.center
        ];

        var anchorPointsOrigin = [
            defs.pub.anchor.left,
            defs.pub.anchor.right,
            defs.prov.anchor.left,
             defs.prov.anchor.right,
            defs.vm.anchor.left,
            defs.vm.anchor.right,
            defs.bc.anchor.bottomLeft,
            defs.bc.anchor.bottomRight
        ];

        var anchorPointsTerminus = [],
              roles = ['pub', 'prov', 'vm', 'bc'],
              sides = ['left', 'right', 'bottomLeft', 'bottomRight'];

        for (var i=0; i<roles.length; ++i) {
            var role = roles[i];

                for (var j=0; j<sides.length; ++j) {
                      var side = sides[j];

                      anchorPointsTerminus.push( getAnchorPoint(role, side, "terminus") );
            }
        }


        var pg = d3.select("svg#Layer_1").append("g");

        pg.selectAll("circle.center-point")
            .data(centerPoints)
          .enter()
            .append("circle")
            .attr("class", "center-point")
            .attr("cx", function(d) {return d.x})
            .attr("cy", function(d) {return d.y})
            .attr("r", 5)
            .attr("fill", "red");

         pg.selectAll("circle.anchor-point-origin")
            .data(anchorPointsOrigin)
          .enter()
            .append("circle")
            .attr("class", "anchor-point-origin")
            .attr("cx", function(d) {return d.x})
            .attr("cy", function(d) {return d.y})
            .attr("r", 5)
            .attr("fill", "green");  

        pg.selectAll("circle.anchor-point-terminus")
            .data(anchorPointsTerminus)
          .enter()
            .append("circle")
            .attr("class", "anchor-point-terminus")
            .attr("cx", function(d) {return d.x})
            .attr("cy", function(d) {return d.y})
            .attr("r", 5)
            .attr("fill", "blue");  
  }

  function init() {   
        var  $pub = $('#publisher #pub-back'),
              $prov = $('#provider #prov-back'),
              $vm = $('#vm #vm-back'),
              $blockchain = $('#blockchain #bc-back');
              
        defs = 
              { 
                  pub: {
                      w: parseFloat($pub.attr('width')), 
                      h: parseFloat($pub.attr('height')),
                      x: parseFloat($pub.attr('x')),
                      y: parseFloat($pub.attr('y'))
                  },
                  prov: {
                     w: parseFloat($prov.attr('width')), 
                      h: parseFloat($prov.attr('height')),
                      x: parseFloat($prov.attr('x')),
                      y: parseFloat($prov.attr('y'))
                  },
                  vm: {
                      w: parseFloat($vm.attr('width')), 
                      h: parseFloat($vm.attr('height')),
                      x: parseFloat($vm.attr('x')) + vmTranslate.x,
                      y: parseFloat($vm.attr('y')) + vmTranslate.y
                  },
                  bc: {
                    radius: parseFloat($blockchain.attr('r')),
                    cx: parseFloat($blockchain.attr('cx')),
                    cy: parseFloat($blockchain.attr('cy'))
                  }
              };


          markerParams = getMarkerParams("arrow-head", 30, 30, 0.5, "black", "steelblue");

          defs.pub.center = {x: defs.pub.x + defs.pub.w / 2, y: defs.pub.y + defs.pub.h / 2};
          defs.pub.anchor = {
                left: {x: defs.pub.x, y: defs.pub.center.y }, 
                right: {x: defs.pub.x + defs.pub.w, y: defs.pub.center.y},
                top: {x: defs.pub.center.x, y: defs.pub.center.y - (defs.pub.h / 2)}
          };
          defs.prov.center = {x: defs.prov.x + defs.prov.w / 2, y: defs.prov.y + defs.prov.h / 2};
          defs.prov.anchor = {
                left: {x: defs.prov.x, y: defs.prov.center.y }, 
                right: {x: defs.prov.x + defs.prov.w, y: defs.prov.center.y},
                top: {x: defs.prov.center.x, y: defs.prov.center.y - (defs.prov.h / 2)}
          };
         
          defs.vm.center = {x: defs.vm.x + defs.vm.w / 2, y: defs.vm.y + defs.vm.h / 2};
          defs.vm.anchor = {
                left: {x: defs.vm.x, y: defs.vm.center.y }, 
                right: {x: defs.vm.x + defs.vm.w, y: defs.vm.center.y}
          };

          defs.bc.center = {x: defs.bc.cx, y: defs.bc.cy};
          defs.bc.anchor = {
            bottomLeft: {x: defs.bc.cx - (defs.bc.radius * Math.cos(Math.PI / 4)), y: defs.bc.cy + (defs.bc.radius * Math.cos(Math.PI / 4))},
            bottomRight: {x: defs.bc.cx + (defs.bc.radius * Math.cos(Math.PI / 4)), y: defs.bc.cy + (defs.bc.radius * Math.sin(Math.PI / 4))}
          };

          lineData = [
            [], // 0
            [   // 1
               
                {
                  id: 1,
                  order: 0,
                  type: 'blockchain',
                  start: linePoints(defs.pub.center), 
                  end: linePoints(defs.pub.center, getAnchorPoint('bc' ,'bottomLeft', 'terminus'))
                },
                 {
                  id: 2,
                  order: 1,
                  type: 'blockchain',
                  start: linePoints(getAnchorPoint('bc' ,'bottomRight', 'origin')), 
                  end: linePoints(getAnchorPoint('bc' ,'bottomRight', 'origin'), getAnchorPoint('prov' ,'top', 'terminus'))
                },
            ],
            [   // 2
               {
                  id: 0,
                  order: 0,
                  type: 'direct',
                  start: linePoints(getAnchorPoint('prov' ,'left', 'origin', {x:0, y: -20})), 
                  end: linePoints(getAnchorPoint('prov' ,'left', 'origin', {x:0, y: -20}), getAnchorPoint('pub' ,'right', 'terminus', {x:-3, y: -20}))
                },
                {
                  id: 3,
                  order: 0,
                  type: 'direct',
                  start: linePoints(defs.pub.center), 
                  end: linePoints(defs.pub.center, getAnchorPoint('prov' ,'left', 'terminus'))
                },
                {
                  id: 4,
                  order: 1,
                  type: 'blockchain',
                  start: linePoints(defs.pub.center), 
                  end: linePoints(defs.pub.center, getAnchorPoint('bc' ,'bottomLeft', 'terminus'))
                },
                 
            ],
            [ // 3
                {
                  id: 5,
                  order: 0,
                  type: 'blockchain',
                  start: linePoints(defs.prov.center), 
                  end: linePoints(defs.prov.center, getAnchorPoint('bc' ,'bottomRight', 'terminus'))
                },
                {
                    id: 6,
                    order: 2,
                    type: 'direct',
                    start: linePoints(defs.pub.center), 
                    end: linePoints(defs.pub.center, getAnchorPoint('vm' ,'left', 'terminus'))
                }
            ]
          ];
    }


    function render() {
        var svg = d3.select("svg#Layer_1");
        //var svg = d3.select("#test")
              // .append("svg")
              // // .attr("width", w)
              // // .attr("height", h)
              // .attr("id", "vis")
              // .attr("xmlns", "http://www.w3.org/2000/svg");

        lg1 = svg.insert("g", ":first-child")
                .attr("class", "line-group")
                .attr("id", "lg1");
        
        lg2 = svg.insert("g", ":first-child")
                .attr("class", "line-group")
                .attr("id", "lg2");                

        var svgdefs = svg.insert("defs",":first-child");

        var marker = svgdefs.append("marker")
                  .attr("id", markerParams.id)
                  .attr("viewBox", markerParams.viewBox)
                  .attr("orient", markerParams.orient)
                  .attr('markerUnits', markerParams.markerUnits)
                  .attr("refX", markerParams.refX)
                  .attr("refY", markerParams.refY)
                  .attr("markerWidth", markerParams.markerWidth)
                  .attr("markerHeight", markerParams.markerHeight);
                  
          var markerPath = marker.append("path")
                  .attr("d", markerParams.d)
                  .attr("stroke-width", markerParams.strokeWidth)
                  .attr("stroke-color", markerParams.strokeColor)
                  .attr("fill", markerParams.fill);
       
          publisher = svg.select('#publisher'),
          provider= svg.select('#provider'),
          vm = svg.select('svg g#vm'),
          blockchain = svg.select('#blockchain');
  }


  function update(step) {

      var durationEnter = 500,
            durationExit = 500;

      

      var arrows = lg1.selectAll("path.arrow")
           .data(lineData[step], function(d) {return d.id});

        arrows.enter()
            .append("path")
            .attr('class', 'arrow')
            .attr("marker-end", "url(#arrow-head)")
            .attr("d", function (d) { return getPath(d.start) })
            .attr("stroke", "steelblue")
            .attr("stroke-width", 12)
            .attr("fill", "none")
            .attr('opacity', 1)
          .transition()
                .duration(durationEnter)
                .delay(function(d) {return d.order * durationEnter * 2})
                .attr("d", function (d) { return getPath(d.end) });
      
        arrows.exit()
              .transition()
                .duration(durationExit)
                .attr('opacity', 0)
              .transition()
                .delay(durationExit)
                .remove();

        var arrowCircles = lg1.selectAll("circle")
            .data(lineData[step].filter( function(d) { return d.id > 0; } ), 
                    function(d) {return d.id});

         arrowCircles.enter()
              .append("circle")
              .attr("cx", function(d) {return d.end[1].x  + textOffset(d.end).x})
              .attr("cy", function(d) {return d.end[1].y  + textOffset(d.end).y})
              .attr("r", 0)
              .attr("fill", "none")
              .attr("stroke", "steelblue")
              .attr("stroke-width", 2)
              .attr('opacity', 1)
          .transition()
              .delay(function(d) {return ((d.order * 2) + 1) * durationEnter})
              .duration(durationEnter)
              .ease('elastic')
              .attr("r", textCircleRadius);

        arrowCircles.exit()
              .transition()
                .duration(durationExit)
                .attr('opacity', 0)
              .transition()
                .delay(durationExit)
                .remove();

        var arrowText = lg1.selectAll("text")
            .data(lineData[step].filter( function(d) { return d.id > 0; } ), 
                    function(d) {return d.id});

        arrowText.enter()
              .append("text")
              .attr("x", function(d) {return d.end[1].x  + textOffset(d.end).x})
              .attr("y", function(d) {return d.end[1].y  +textOffset(d.end).y + 6})
              .attr("text-anchor", "middle")
              .attr("font-family", "sans-serif")
              .attr("font-size", "18px")
              .attr("fill", "red")
              .attr('opacity', 0)
              .text(function(d) {return d.id})
          .transition()
              .delay(function (d) {return ((d.order * 2) + 1)  * durationEnter})
              .duration(durationEnter)
              .attr('opacity', 1);

        arrowText.exit()
              .transition()
                .duration(durationExit)
                .attr('opacity', 0)
              .transition()
                .delay(durationExit)
                .remove();

      if (step === 3) {
          var vmOrder = 1;

           vm
           .transition()
              .duration(durationEnter)
              .delay(vmOrder * 2 * durationEnter)
              .attr('transform', 'translate(' + vmTranslate.x + ',' + vmTranslate.y + ')')
              .attr('opacity', 1);

          } 
          else {
              vm
                .attr('opacity', 0.3)    
                .attr('transform', 'translate(0,0)')
          }
   } //update
   
    $("#stage").load('diagram.svg',function(response){
 
          $(this).addClass("svgLoaded");

          if(!response){
              // Error loading SVG!
              // Make absolutely sure you are running this on a web server or localhost!
              return;
          }

          init()
          render();
 
    });

      /*******************     EVENT HANDLERS   *****************/
      $('li.button').click(function() {
          var step = parseInt($(this).attr('step'));

          console.log('STEP', $(this).attr('step'))
          $('li.button.active').removeClass('active');
          $(this).addClass('active');

          update(step);
      })   
    });
  </script>
</body>
</html>